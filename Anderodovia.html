<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Night Drive</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; font-size: 24px; pointer-events: none; }
        #instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: white; }
    </style>
</head>
<body>
    <div id="ui">Pontos: <span id="score">0</span></div>
    <div id="instructions">Use as SETAS ou TOQUE nas laterais da tela</div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';

        // --- CONFIGURAÇÃO DA CENA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 10, 50); // Neblina para o horizonte escuro

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- ELEMENTOS DO CENÁRIO (IGUAL À FOTO) ---
        // Estrada
        const roadGeo = new THREE.PlaneGeometry(20, 1000);
        const roadMat = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        // Grama lateral
        const grassGeo = new THREE.PlaneGeometry(100, 1000);
        const grassMat = new THREE.MeshPhongMaterial({ color: 0x004400 });
        const grass = new THREE.Mesh(grassGeo, grassMat);
        grass.rotation.x = -Math.PI / 2;
        grass.position.y = -0.1;
        scene.add(grass);

        // Iluminação
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        // Criar o Carro do Jogador (Azul da foto)
        const playerGroup = new THREE.Group();
        const bodyGeo = new THREE.BoxGeometry(1, 0.6, 2);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0x00aaff });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        playerGroup.add(body);
        
        // Faróis do jogador
        const headlight = new THREE.SpotLight(0xffffff, 2);
        headlight.position.set(0, 0, 1);
        playerGroup.add(headlight);

        scene.add(playerGroup);
        playerGroup.position.y = 0.4;
        playerGroup.position.z = 5;

        // --- SISTEMA DE OBSTÁCULOS E AMBIENTE ---
        const obstacles = [];
        const buildings = [];

        function createBuilding(zPos, side) {
            const colors = [0x8b4513, 0x008080, 0x4682b4, 0xd2691e];
            const h = 5 + Math.random() * 5;
            const geo = new THREE.BoxGeometry(2, h, 2);
            const mat = new THREE.MeshPhongMaterial({ color: colors[Math.floor(Math.random()*colors.length)] });
            const b = new THREE.Mesh(geo, mat);
            b.position.set(side * 8, h/2, zPos);
            scene.add(b);
            buildings.push(b);
        }

        function createObstacle() {
            const isBus = Math.random() > 0.7;
            const geo = isBus ? new THREE.BoxGeometry(1.2, 1.2, 4) : new THREE.BoxGeometry(1, 0.6, 2);
            const mat = new THREE.MeshPhongMaterial({ color: isBus ? 0xff3333 : 0xffff00 });
            const obs = new THREE.Mesh(geo, mat);
            obs.position.set((Math.random() - 0.5) * 10, isBus ? 0.6 : 0.4, -50);
            scene.add(obs);
            obstacles.push(obs);
        }

        // --- LÓGICA DO JOGO ---
        let score = 0;
        const speed = 0.5;
        const keys = { left: false, right: false };

        window.addEventListener('keydown', (e) => {
            if(e.key === "ArrowLeft") keys.left = true;
            if(e.key === "ArrowRight") keys.right = true;
        });
        window.addEventListener('keyup', (e) => {
            if(e.key === "ArrowLeft") keys.left = false;
            if(e.key === "ArrowRight") keys.right = false;
        });

        // Touch para Mobile
        window.addEventListener('touchstart', (e) => {
            if(e.touches[0].clientX < window.innerWidth/2) keys.left = true;
            else keys.right = true;
        });
        window.addEventListener('touchend', () => { keys.left = false; keys.right = false; });

        function animate() {
            requestAnimationFrame(animate);

            // Movimento do jogador
            if(keys.left && playerGroup.position.x > -8) playerGroup.position.x -= 0.15;
            if(keys.right && playerGroup.position.x < 8) playerGroup.position.x += 0.15;

            // Movimentar estrada (ilusão de ótica)
            road.position.z += speed;
            if(road.position.z > 100) road.position.z = 0;

            // Gerar prédios e inimigos
            if(Math.random() < 0.05) {
                createBuilding(-100, Math.random() > 0.5 ? 1 : -1);
            }
            if(Math.random() < 0.02) createObstacle();

            // Atualizar obstáculos
            obstacles.forEach((obs, index) => {
                obs.position.z += speed;
                
                // Colisão simples
                if(Math.abs(obs.position.z - playerGroup.position.z) < 1.5 && 
                   Math.abs(obs.position.x - playerGroup.position.x) < 1) {
                    alert("Gamer Over! Pontos: " + score);
                    location.reload();
                }

                if(obs.position.z > 10) {
                    scene.remove(obs);
                    obstacles.splice(index, 1);
                    score++;
                    document.getElementById('score').innerText = score;
                }
            });

            // Atualizar prédios
            buildings.forEach((b, index) => {
                b.position.z += speed;
                if(b.position.z > 20) {
                    scene.remove(b);
                    buildings.splice(index, 1);
                }
            });

            camera.position.set(playerGroup.position.x * 0.5, 3, 12);
            camera.lookAt(playerGroup.position.x, 0, -5);

            renderer.render(scene, camera);
        }

        animate();

        // Ajuste de tela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
