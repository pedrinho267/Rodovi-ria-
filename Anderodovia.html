<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Highway Pro - Engine V2</title>
    <style>
        :root { --neon: #00d2ff; --warn: #ff3e3e; }
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; }
        canvas { display: block; touch-action: none; }
        
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; color: white;
        }

        .screen {
            position: absolute; inset: 0; background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; pointer-events: all; backdrop-filter: blur(8px);
        }

        #hud { width: 90%; display: flex; justify-content: space-between; padding: 20px; font-size: 20px; font-weight: bold; }
        .neon-text { text-shadow: 0 0 10px var(--neon); color: var(--neon); }
        button {
            padding: 15px 40px; font-size: 20px; background: none; 
            border: 2px solid var(--neon); color: white; cursor: pointer;
            transition: 0.3s; box-shadow: 0 0 10px var(--neon);
        }
        button:hover { background: var(--neon); color: black; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="hud" class="hidden">
            <div>DISTÂNCIA: <span id="dist-val" class="neon-text">0</span>m</div>
            <div>VELOCIDADE: <span id="speed-val" class="neon-text">0</span>km/h</div>
        </div>
        
        <div id="main-menu" class="screen">
            <h1 class="neon-text" style="font-size: 60px;">SUPER DRIVE</h1>
            <button onclick="Game.start()">IGNIÇÃO</button>
        </div>

        <div id="game-over" class="screen hidden">
            <h1 style="color: var(--warn); font-size: 50px;">FATAL ERROR</h1>
            <p id="final-stats" style="margin-bottom: 20px;"></p>
            <button onclick="Game.start()" style="border-color: var(--warn); box-shadow: 0 0 10px var(--warn);">REINICIAR</button>
        </div>
    </div>

<script>
/**
 * ENGINE CORE: Pseudo-3D Rendering & Physics
 * Baseado no algoritmo de projeção de segmentos clássico.
 */
const Game = {
    // Boilerplate
    canvas: document.getElementById('gameCanvas'),
    ctx: null,
    dpr: window.devicePixelRatio || 1,
    
    // Configurações de Mundo
    fieldOfView: 100,
    cameraHeight: 1000,
    drawDistance: 300,
    segmentLength: 200,
    roadWidth: 2000,
    
    // Estado
    state: 'MENU',
    position: 0,
    speed: 0,
    maxSpeed: 25000, // Unidades/seg
    playerX: 0,
    obstacles: [],
    
    init() {
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.bindEvents();
        this.loop();
    },

    resize() {
        this.canvas.width = window.innerWidth * this.dpr;
        this.canvas.height = window.innerHeight * this.dpr;
        this.ctx.scale(this.dpr, this.dpr);
        this.screenW = window.innerWidth;
        this.screenH = window.innerHeight;
        this.cameraDepth = 1 / Math.tan((this.fieldOfView / 2) * Math.PI / 180);
    },

    start() {
        this.state = 'PLAYING';
        this.position = 0;
        this.speed = 1000;
        this.playerX = 0;
        this.obstacles = [];
        this.lastUpdateTime = performance.now();
        
        document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
        document.getElementById('hud').classList.remove('hidden');
    },

    // Projeção 3D -> 2D
    project(pX, pY, pZ) {
        const relZ = pZ - this.position;
        const scale = this.cameraDepth / relZ;
        return {
            x: (this.screenW / 2) + (scale * pX * this.screenW / 2),
            y: (this.screenH / 2) - (scale * (pY - this.cameraHeight) * this.screenH / 2),
            w: scale * this.roadWidth * this.screenW / 2
        };
    },

    update(dt) {
        if (this.state !== 'PLAYING') return;

        // Física e Aceleração
        const accel = 800;
        this.speed = Math.min(this.speed + accel * dt, this.maxSpeed);
        this.position += this.speed * dt;

        // Input com suavização
        const targetX = this.keys.left ? -1.2 : (this.keys.right ? 1.2 : 0);
        this.playerX += (targetX - this.playerX) * 10 * dt;

        // Spawn de Obstáculos (Baseado em distância, não tempo)
        if (this.obstacles.length < 8) {
            const lastZ = this.obstacles.length ? this.obstacles[this.obstacles.length-1].z : this.position;
            if (lastZ - this.position < 20000) {
                this.obstacles.push({
                    x: (Math.random() * 2 - 1),
                    z: lastZ + 5000 + Math.random() * 5000,
                    w: 400
                });
            }
        }

        // Colisão e HUD
        document.getElementById('dist-val').innerText = Math.floor(this.position / 100);
        document.getElementById('speed-val').innerText = Math.floor(this.speed / 100);

        for (let i = this.obstacles.length - 1; i >= 0; i--) {
            const o = this.obstacles[i];
            if (o.z < this.position) {
                this.obstacles.splice(i, 1);
                continue;
            }
            
            // Colisão AABB Swept (simplificada para profundidade)
            if (o.z - this.position < 250 && o.z - this.position > -250) {
                const playerRealX = this.playerX * (this.roadWidth / 2);
                const obstacleRealX = o.x * (this.roadWidth / 2);
                if (Math.abs(playerRealX - obstacleRealX) < 600) {
                    this.die();
                }
            }
        }
    },

    die() {
        this.state = 'GAMEOVER';
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-stats').innerText = `DISTÂNCIA PERCORRIDA: ${Math.floor(this.position / 100)}m`;
    },

    draw() {
        const ctx = this.ctx;
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, this.screenW, this.screenH);

        // Horizonte
        ctx.fillStyle = '#0a0a20';
        ctx.fillRect(0, this.screenH/2, this.screenW, this.screenH/2);

        // Render Road Segments
        const startPos = Math.floor(this.position / this.segmentLength) * this.segmentLength;
        
        for (let n = 0; n < this.drawDistance; n++) {
            const z1 = startPos + n * this.segmentLength;
            const z2 = z1 + this.segmentLength;
            
            const p1 = this.project(0, 0, z1);
            const p2 = this.project(0, 0, z2);

            if (p1.y <= p2.y) continue;

            // Renderização em cores alternadas para percepção de velocidade
            const color = (Math.floor(z1/this.segmentLength) % 2) ? '#222' : '#282828';
            const line = (Math.floor(z1/this.segmentLength) % 2) ? '#00d2ff' : 'transparent';

            // Road Body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(p1.x - p1.w, p1.y);
            ctx.lineTo(p1.x + p1.w, p1.y);
            ctx.lineTo(p2.x + p2.w, p2.y);
            ctx.lineTo(p2.x - p2.w, p2.y);
            ctx.fill();

            // Neon Borders
            if (line !== 'transparent') {
                ctx.strokeStyle = line;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Render Obstacles (Back to Front)
        this.obstacles.slice().reverse().forEach(o => {
            const p = this.project(o.x * this.roadWidth/2, 0, o.z);
            if (p.y > this.screenH / 2 && p.y < this.screenH) {
                ctx.fillStyle = '#ff3e3e';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff3e3e';
                ctx.fillRect(p.x - p.w/10, p.y - p.w/5, p.w/5, p.w/5);
                ctx.shadowBlur = 0;
            }
        });

        // Render Player (Fixo no espaço de tela para menor latência)
        const pSize = 120;
        ctx.fillStyle = '#00d2ff';
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00d2ff';
        const pX = (this.screenW / 2) + (this.playerX * this.screenW / 4);
        ctx.fillRect(pX - pSize/2, this.screenH - 120, pSize, pSize/2);
        ctx.shadowBlur = 0;
    },

    bindEvents() {
        this.keys = { left: false, right: false };
        const handler = (val) => (e) => {
            if (e.key === 'ArrowLeft') this.keys.left = val;
            if (e.key === 'ArrowRight') this.keys.right = val;
        };
        window.addEventListener('keydown', handler(true));
        window.addEventListener('keyup', handler(false));
        
        // Touch
        this.canvas.addEventListener('touchstart', (e) => {
            const x = e.touches[0].clientX;
            if (x < this.screenW / 2) this.keys.left = true;
            else this.keys.right = true;
        });
        this.canvas.addEventListener('touchend', () => {
            this.keys.left = false;
            this.keys.right = false;
        });
    },

    loop() {
        const now = performance.now();
        const dt = Math.min((now - this.lastUpdateTime) / 1000, 0.1);
        this.lastUpdateTime = now;

        this.update(dt);
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

Game.init();
</script>
</body>
</html>
