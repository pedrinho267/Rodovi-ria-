<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ultra Performance 3D Night</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; color: #0f0; font-family: 'Courier New', monospace; pointer-events: none; font-size: 12px; }
        .controls { position: absolute; bottom: 20px; width: 100%; display: flex; justify-content: space-around; }
        .btn { width: 70px; height: 70px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; user-select: none; pointer-events: auto; }
    </style>
</head>
<body>
    <div id="ui">MEMÓRIA: ESTÁVEL | GPU: OPTIMIZED | 60FPS</div>
    <div class="controls">
        <div class="btn" id="lBtn">←</div>
        <div class="btn" id="rBtn">→</div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SETUP DE ALTA PERFORMANCE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 15, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limita resolução para evitar lag
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- LUZES OTIMIZADAS (Lambert/Phong em vez de Standard) ---
        const light = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
        scene.add(light);

        // --- GEOMETRIAS ÚNICAS (BufferGeometry para economia de GPU) ---
        const boxGeo = new THREE.BoxGeometry(1, 1, 1);
        const cylinderGeo = new THREE.CylinderGeometry(0.1, 0.1, 1);
        const planeGeo = new THREE.PlaneGeometry(1, 1);

        // --- MATERIAIS LEVES ---
        const roadMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x051a05 });
        const buildingMat = new THREE.MeshLambertMaterial({ color: 0x333344 });

        // --- OBJECT POOLING (REUSO DE OBJETOS) ---
        const pool = [];
        const poolSize = 20;
        const spacing = 15;

        for (let i = 0; i < poolSize; i++) {
            const group = new THREE.Group();
            
            // Prédio
            const build = new THREE.Mesh(boxGeo, buildingMat);
            const h = 5 + Math.random() * 10;
            build.scale.set(3, h, 3);
            build.position.set(Math.random() > 0.5 ? 10 : -10, h/2, 0);
            
            // Poste
            const pole = new THREE.Mesh(cylinderGeo, buildingMat);
            pole.scale.set(1, 6, 1);
            pole.position.set(build.position.x > 0 ? 7 : -7, 3, 0);
            
            // Luz do poste (Ponto de luz otimizado)
            const pLight = new THREE.PointLight(0xffaa00, 10, 15);
            pLight.position.set(0, 3, 0);
            pole.add(pLight);

            group.add(build, pole);
            group.position.z = -i * spacing;
            
            scene.add(group);
            pool.push(group);
        }

        // Estrada Estática
        const road = new THREE.Mesh(planeGeo, roadMat);
        road.scale.set(14, 1000, 1);
        road.rotation.x = -Math.PI / 2;
        scene.add(road);

        // --- CARRO DO JOGADOR ---
        const car = new THREE.Mesh(boxGeo, new THREE.MeshLambertMaterial({ color: 0x0077ff }));
        car.scale.set(1.2, 0.6, 2.2);
        car.position.set(0, 0.3, -5);
        scene.add(car);

        // --- CONTROLES ---
        let moveX = 0;
        const keys = { left: false, right: false };

        const updateInput = (key, val) => { keys[key] = val; };
        window.onkeydown = (e) => { if(e.code=='ArrowLeft') keys.left=true; if(e.code=='ArrowRight') keys.right=true; };
        window.onkeyup = (e) => { if(e.code=='ArrowLeft') keys.left=false; if(e.code=='ArrowRight') keys.right=false; };
        
        document.getElementById('lBtn').ontouchstart = () => keys.left = true;
        document.getElementById('lBtn').ontouchend = () => keys.left = false;
        document.getElementById('rBtn').ontouchstart = () => keys.right = true;
        document.getElementById('rBtn').ontouchend = () => keys.right = false;

        // --- LOOP PRINCIPAL (ANTI-TRAVA) ---
        const speed = 0.6;
        camera.position.set(0, 4, 2);
        camera.lookAt(0, 0, -15);

        function animate() {
            requestAnimationFrame(animate);

            // Mover pool de objetos (Object Pooling)
            pool.forEach(obj => {
                obj.position.z += speed;
                if (obj.position.z > 10) {
                    obj.position.z = -(poolSize - 1) * spacing;
                }
            });

            // Movimento do carro
            if (keys.left && car.position.x > -5) car.position.x -= 0.15;
            if (keys.right && car.position.x < 5) car.position.x += 0.15;
            
            camera.position.x = car.position.x * 0.5;

            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
